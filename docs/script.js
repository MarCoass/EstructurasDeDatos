//atributo clave agregado para no tener problemas con espacios (antes usaba nombre para encontrar el elemento en localizarElem())
class Estructura {
    constructor(nombre, info, img, clave) {
        this.nombre = nombre;
        this.info = info;
        this.img = img;
        this.clave = clave;
    }
}
//se podria armar un array
const pila = new Estructura('Pila', '<p>Es una estructura donde el ultimo elemento en entrar es el primero en salir (LIFO, Last in First Out), por lo que solo se tiene acceso al tope de la pila, donde se realizan todas las operaciones y es el unico elemento visible. Tiene implementacion estatica (mediante un array) y dinamica (nodos enlazados)</p><ul>Operaciones:<li>Constructor vacio</li><li>apilar(elem): boolean</li><li>desapilar(): boolean</li><li>obtenerTope(): elem</li><li>esVacia(): boolean</li><li>vaciar()</li><li>clone(): Pila</li><li>toString(): String</li></ul>', 'assets/pila.png', 'pila');
const cola = new Estructura('Cola', '<p>Estructura en la que el primer elemento en entrar es el primero en salir (FIFO, First In First Out). Se tiene acceso al frente de la cola para ver o eliminar el primer elemento y al final par agregar nuevos elementos.<br> Tiene implementacion estatica (utilizando un arreglo que es recorrido de manera circular) y dinamica (nodos enlazados)</p><ul>Operaciones: <br> <li>Constructor vacio</li><li>poner(elem): boolean</li><li>sacar(): boolean</li><li>obtenerFrente(): elem</li><li>esVacio(): boolean</li><li>vaciar()</li><li>clone(): Cola</li><li>toString(): String</li></ul>', 'assets/cola.png', 'cola');
const lista = new Estructura('Lista', '<p>Secuencia de elementos que puede crecer o acortarse segun sea necesario. Los elementos de una lista se pueden insertar acceder, borrar y consultar por posiciones, siendo 1 la primer posicion.</p><ul>Operaciones:<br><li>Constructor vacio</li><li>insertar(elem, pos): boolean</li><li>eliminar(pos): boolean</li><li>recuperar(pos): elem</li><li>localizar(elem): int</li><li>vaciar()</li><li>esVacia(): boolean</li><li>longituh(): int</li><li>clone(): Lista</li><li>toString(): String</li></ul>', 'assets/lista.png', 'lista');
const binario = new Estructura('Arbol Binario', '<p>Estructuras que permiten organizar un conjunto de datos en forma jerarquica. Se puede definir como un conjunto finito de nodos, donde se distingue un nodo especial llamado raiz, que provee acceso al arbol. A diferencia de las estructuras lineales, en un arbol los nodos poseen una relacion de paternidad donde cada nodo (excepto la raiz) esta relacionada con un nodo padre y cada nodo tiene maximo 2 hijos.</p><ul>Operaciones: <br><li>Constructor vacio </li><li>insertar(elemNuevo, elemPadre, posicion):boolean</li><li>esVacio(): boolean</li><li>altura(): int</li><li>nivel(elem): int</li><li>padre(elem): elemPadre</li><li>pertenece(elem): boolean</li><li>ancestros(elem): Lista</li><li>listarPreOrden(), listarInOrden(), listarPosOrden(), listarPorNiveles(): Lista</li><li>clone(): ArbolGen</li><li>toString(): String</li><li>vaciar()</li></ul>', 'assets/arbolbinario.png', 'binario');
const generico = new Estructura('Arbol Generico', '<p>Estos arboles respetan la misma terminologia que los Arboles Binarios, pero no estan limitados a 2 hijos por nodo. Se implementan de forma dinamica y para no limitar la cantidad de hijos, el nodo padre se enlaza al primer hijo (hijo extremo izquierdo) y los otros hijos se almacenan enlazados unos a otros (enlace al hermano derecho).</p><ul>Operaciones: <br><li>Constructor vacio </li><li>insertar(elemNuevo, elemPadre):boolean</li><li>pertenece(elem): boolean</li><li>ancestros(elem): Lista</li><li>esVacio(): boolean</li><li>altura(): int</li><li>nivel(elem): int</li><li>padre(elem): elemPadre</li><li>listarPreOrden(), listarInOrden(), listarPosOrden(), listarPorNiveles(): Lista</li><li>clone(): ArbolGen</li><li>toString(): String</li><li>vaciar()</li></ul>', 'assets/arbolgenerico.png', 'generico');
const heap = new Estructura('Heap', '<p>Un arbol heap o monticulo, es una estructura que permite mantener sus elementos parcialmente ordenados para permitir encontrar rapidamente el menor o mayor elemento. Esta basado en una estructura de arbol binario con 2 restricciones: <br>&nbsp;&nbsp;&nbsp;&nbsp;Propiedad Heap: cada nodo contiene un valor mayor que el de sus hijos (heap maximo) o menor (heap minimo) <br>&nbsp;&nbsp;&nbsp;&nbsp;Arbol semi-completo: el arbol esta siempre balanceado (todos los caminos desde la raiz hasta una hija tienen maximo 1 de diferencia) y las inserciones se realizan en el ultimo nivel del arbol, de izquierda a derecha.<br>Se les llama parcialmente ordenados porque el orden entre hermanos no esta especificado, de manera que los subarboles de cualquier noso son intercambiables.<br>Respecto a la implementacion, si bien es posible implementarlo como un arbol binario, por la condicion de arbol semi-completo permite ser representado utilizando un arreglo. No es necesario almacenar los enlaces, ya que siempre se puede calcular la posicion de los hijos o la del padre a partir de la posicion de un nodo en el arreglo.</p><ul>Operaciones: <br> <li>Constructor vacio</li><li>insertar(elem): boolean</li><li>eliminarCima(): boolean</li><li>recuperarCima(): elem</li><li>esVacio(): boolean</li><li>vaciar()</li><li>clone(): Heap</li><li>toString(): String</li></ul>', 'assets/heap.png', 'heap');
const abb = new Estructura('Arbol Binario de Busqueda', '<p>Es un arbol binario con la caracteristica de que todos los elemenos del subarbol izquierdo de cualquier nodo(si no esta vacio) son menores que el valor de dicho nodo y todos los elementos del subarbol derecho(si no esta vacio) son mayores que el. Por esto se dice que un ABB es un arbol ordenado. <br>La principal caracteristica es que la busqueda de un elemento es eficiente en la mayoria de los casos, ya que se puede saber la posible ubicacion del elemento sin visitar todos los nodos. Para mantener tal eficiencia no se admiten elementos repetidos.</p><ul>Operaciones: <br><li>Constructor vacio</li><li>insertar(elem): boolean</li><li>eliminar(elem): boolean</li><li>pertenece(elem): boolean</li><li>esVacio(): boolean</li><li>listar(): Lista</li><li>listarRango(elemMin, elemMax): Lista</li><li>minimoElemento(): elem</li><li>maximoElemento(): elem</li><li>vaciar()</li><li>clone(): ArbolBB</li><li>toString(): String</li></ul>', 'assets/abb.png', 'abb');
const avl = new Estructura('AVL', '<p>Son arboles binarios que estan siempre equilibrados, de tal modo que para todos los nodos, la altura de la rama izquierda no difiere en mas de una unidad de la altura de la rama derecha. Gracias al balanceo, la complejidad de la busqueda siempre se mantiene en O(log n).<br>Para implementarlo se usa la estructura de un ABB con las operaciones insertar y eliminar modificadas para asegurar que los subarboles izq y der se mantengan balanceados. Tal balance se calcula restando la altura del hijo izq y del hiojo der, este calculo se hace despues de insertar o eliminar un nodo(a la vuelta de la recursion), ya que en caso de que el balance de -2 o 2, hay que reorganizar el arbol para recuperar el balance.<br>Para balancear el arbol se tiene 4 posibles rotaciones: simples (izq y der) o dobles (izq y der), las simples se aplican cuando el balance del nodo padre y nodo hijo que causa el desbalance coinciden en signo, es decir, padre e hijos caidos hacia el mismo lado, en caso contrario se usa rotacion doble</p><ul>Operaciones: <br><li>Constructor vacio</li><li>insertar(elem): boolean</li><li>eliminar(elem): boolean</li><li>pertenece(elem): boolean</li><li>esVacio(): boolean</li><li>listar(): Lista</li><li>listarRango(elemMin, elemMax): Lista</li><li>minimoElemento(): elem</li><li>maximoElemento(): elem</li><li>vaciar()</li><li>clone(): ArbolBB</li><li>toString(): String</li><li>Como metodos private se agregan los necesarios para mantener el arbol balanceado</li></ul>', 'assets/avl.png', 'avl');
const hash = new Estructura('Hash', '<p>Una tabla hash se construye en base a un arreglo de celdas, que sera la estructura que almacene la informacion y una funcion de dispersion o funcion hash. La función hash permitira asociar cada elemento con una celda donde dicho elemento debe almacenarse o buscarse. Lo deseado es que dadas 2 claves distintas, el resultado de la funcion hash ( es decir, su posicion en la tabla) sea distinto. Por el contrario, cuando 2 claves distintas obtienen el mismo valor de la funcion hash, se dice que ocurre una colision.<br><h4>Funciones Hash</h4>Se necesita una funcion que transforme los elementos (sin importar su tipo) en enteros en un rango [0...M-1], donde M es el tamaño de la tabla o arreglo. Como ya se dijo, la funcion debe minimizar las colisiones y debe ser relativcamente rapida y facil de calcular, por lo que existen varias estrategias para esto: <ul><li>Doblamiento</li><li>Funcion cuadrado</li><li>Division por un numero primo</li><li>Operando con clave tipo cadena(suma de valores ASCII)</li></ul><br>La tabla hash debera estar preparada para poder almacenar elementos aunque colisionen entre si. Con este objetivo, existen 2 tipos de tablas hash, en funcion de como se resuelven las colisiones.<br><h4>Hash abierto</h4>Las colisiones se resuelven insertando los elementos que colisionan en una lista, de esa forma se tiene como estructura un arreglo de listas. Al numero medio de elementos por lista se le llama factor de carga y se intenta que sea lo mas pequeño posible.<h4>Hash cerrado</h4>Se utiliza un arreglo de elementos como representacion y cuando se produce una colision se la resuelve reasignandole otro valor hash al elemento hasta que se encuentre un hueco libre.<br></p><ul>Operaciones: <br><li>Constructor vacio</li><li>insertar(elem): boolean</li><li>eliminar(elem): boolean</li><li>pertenece(elem): boolean</li><li>esVacia(): boolean</li><li>listar(): Lista</li><li>vaciar()</li><li>clone(): Hash</li><li>toString(): String</li></ul>', 'assets/hash.png', 'hash');

const array = [pila, cola, lista, binario, generico, heap, abb, avl, hash];

const body = document.getElementById("body");
const opciones = document.getElementById("opciones");


opciones.addEventListener("click", function (e) {
    cargarInfo(event.target.id);
},
    false
);



function cargarInfo(seleccion) {
    //busco el objeto que coincida con seleccion
    let elem = localizarElemento(seleccion);
    //inserto el codigo html con los datos del elem
    body.innerHTML = '<div class="elemTitle">' + elem.nombre + '</div><div class="elemInfo">' + elem.info + '</div><div class="elemImg"><img src="'+elem.img+'" alt="imagen de estructura"></div>';
}

function localizarElemento(buscado) {
    //funcion que localiza el elemento del array cuyo nombre coincide con el id de la opcion seleccionada
    let encontrado = false;
    let pos = 0;
    while (!encontrado && pos <= array.length) {
        if (array[pos].clave == buscado) {
            encontrado = true;
        } else {
            pos++;
        }
    }
    return array[pos];
}
